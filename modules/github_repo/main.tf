# ----------------------------------------------------
# 1. DATA AND LOCALS (ECR URL Generation)
# ----------------------------------------------------

# List of ECR repositories required by the application
locals {
  app_repositories = ["node-repo", "nginx-repo", "cli-repo"]
}

provider "github" {
  token = var.github_token
  owner = var.github_owner
}

# Generate the JSON string containing all ECR URLs
locals {
  ecr_urls_map = {
    for repo in local.app_repositories : 
    repo => "${data.aws_caller_identity.current.account_id}.dkr.ecr.${var.aws_region}.amazonaws.com/${var.app_name}-${repo}"
  }
  ecr_urls_json = jsonencode(local.ecr_urls_map)
}

# Get current AWS account ID
data "aws_caller_identity" "current" {}


# ----------------------------------------------------
# 2. GITHUB REPOSITORY & SECRETS
# ----------------------------------------------------

# 2.1 Create new repository from template
resource "github_repository" "new_app_repo" {
  name        = var.app_name
  description = "Application repository generated by Terraform"
  visibility  = "private"

  template {
    owner      = split("/", var.repo_template)[0]
    repository = split("/", var.repo_template)[1]
  }

  has_issues   = true
  has_projects = true
  has_wiki     = false
  auto_init    = true 
}

# 2.2 GitHub Actions Secrets (Kept in case they are needed for other purposes)
resource "github_actions_secret" "aws_key_id" {
  repository      = github_repository.new_app_repo.name
  secret_name     = "AWS_ACCESS_KEY_ID"
  plaintext_value = var.aws_access_key_id
}

resource "github_actions_secret" "aws_secret_key" {
  repository      = github_repository.new_app_repo.name
  secret_name     = "AWS_SECRET_ACCESS_KEY"
  plaintext_value = var.aws_secret_access_key
}


# ----------------------------------------------------
# 3. REPOSITORY FILES
# ----------------------------------------------------

# 3.1 Add the docker-compose deployment file
resource "github_repository_file" "deploy_compose_file" {
  repository          = github_repository.new_app_repo.name
  file                = "docker-compose.deploy.yml"
  content             = templatefile("${path.module}/templates/docker_compose_deploy.tpl", {
    node_uri       = jsondecode(local.ecr_urls_json)["node-repo"]
    nginx_uri      = jsondecode(local.ecr_urls_json)["nginx-repo"]
    cli_uri        = jsondecode(local.ecr_urls_json)["cli-repo"]
    POSTGRES_DB     = "$${POSTGRES_DB}"
    POSTGRES_USER   = "$${POSTGRES_USER}"
    POSTGRES_PASSWORD = "$${POSTGRES_PASSWORD}"
    DB_PORT         = "$${DB_PORT}"
    NODE_ENV        = "$${NODE_ENV}"
    APP_PORT        = "$${APP_PORT}"
    SECRET_KEY      = "$${SECRET_KEY}"
  })
  commit_message      = "Terraform: Add dynamic docker-compose.deploy.yml"
  overwrite_on_create = true
  depends_on          = [github_repository.new_app_repo]
}

# 3.2 Add the deployment script (deploy.sh)
resource "github_repository_file" "deploy_script" {
  repository          = github_repository.new_app_repo.name
  file                = "deploy.sh"
  content             = file("${path.module}/templates/deploy.sh")
  commit_message      = "Terraform: Add deployment script"
  overwrite_on_create = true
  depends_on          = [github_repository.new_app_repo]
}

# 3.3 Add the Jenkinsfile with ECR Push capabilities
resource "github_repository_file" "jenkinsfile_update" {
  repository          = github_repository.new_app_repo.name
  file                = "Jenkinsfile" 
  content             = templatefile("${path.module}/templates/jenkinsfile.tpl", {
    # Existing variables
    app_instance_id = var.app_instance_id
    app_name        = var.app_name
    github_owner    = var.github_owner
    aws_region      = var.aws_region

    # Pass the full ECR URIs to the template
    ecr_node_uri    = jsondecode(local.ecr_urls_json)["node-repo"]
    ecr_nginx_uri   = jsondecode(local.ecr_urls_json)["nginx-repo"]
    ecr_cli_uri     = jsondecode(local.ecr_urls_json)["cli-repo"]
  })
  commit_message      = "Terraform: Update Jenkinsfile to handle ECR push"
  overwrite_on_create = true
  depends_on          = [
    github_repository.new_app_repo, 
    github_repository_file.deploy_compose_file
  ]
}

# ----------------------------------------------------
# OUTPUTS & VARIABLES
# ----------------------------------------------------

output "http_clone_url" {
  description = "The HTTPS URL to clone the application repository."
  value       = github_repository.new_app_repo.http_clone_url 
}

# --- GitHub Configuration Variables ---

variable "app_name" {
  description = "Application name used for naming the new repository."
  type        = string
}

variable "github_token" {
  description = "GitHub Personal Access Token (PAT) with 'repo' and 'workflow' scopes."
  type        = string
  sensitive   = true 
}

variable "github_owner" {
  description = "The GitHub organization or user where the repository will be created."
  type        = string
}

variable "repo_template" {
  description = "Full name of the template repository (owner/repo-name)."
  type        = string
  validation {
    condition     = contains(["DanteBelNan/node_template", "DanteBelNan/html_template"], var.repo_template)
    error_message = "The value for repo_template must be one of the valid options: 'DanteBelNan/node_template' or 'DanteBelNan/html_template'."
  }
}

# --- CI/CD Configuration Variables (Secrets and ECR) ---

variable "aws_access_key_id" {
  description = "AWS Access Key ID for configuring GitHub Secrets."
  type        = string
  sensitive   = true
}

variable "aws_secret_access_key" {
  description = "AWS Secret Access Key for configuring GitHub Secrets."
  type        = string
  sensitive   = true
}

variable "aws_region" {
  description = "AWS Region, used for injection into the workflow."
  type        = string
  default     = "us-east-2"
}

variable "app_instance_id" {
  description = "The EC2 Instance ID of the application server (Compute) where deployment occurs."
  type        = string
}